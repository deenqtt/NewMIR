var NAV2D = NAV2D || {
  REVISION: "0.3.0",
};

NAV2D.ImageMapClientNav = function (options) {
  var that = this;
  options = options || {};
  this.ros = options.ros;
  var topic = options.topic || "/map";
  var image = options.image;
  this.serverName = options.serverName || "/navigate_to_pose";
  this.actionName = options.actionName || "nav2_msgs/NavigateToPose";
  this.rootObject = options.rootObject || new createjs.Container();
  this.viewer = options.viewer;
  this.withOrientation = options.withOrientation || false;

  this.navigator = null;

  var client = new ROS2D.ImageMapClient({
    ros: this.ros,
    rootObject: this.rootObject,
    topic: topic,
    image: image,
  });

  client.on("change", function () {
    that.navigator = new NAV2D.Navigator({
      ros: that.ros,
      serverName: that.serverName,
      actionName: that.actionName,
      rootObject: that.rootObject,
      withOrientation: that.withOrientation,
    });

    that.viewer.scaleToDimensions(
      client.currentImage.width,
      client.currentImage.height
    );
    that.viewer.shift(
      client.currentImage.pose.position.x,
      client.currentImage.pose.position.y
    );
  });

  client.on("error", function (error) {
    console.error("Error in ImageMapClient: ", error);
  });
};

NAV2D.OccupancyGridClientNav = function (options) {
  var that = this;
  options = options || {};
  this.ros = options.ros;
  var topic = options.topic || "/map";
  this.serverName = options.serverName || "/navigate_to_pose";
  this.actionName = options.actionName || "nav2_msgs/NavigateToPose";
  this.rootObject = options.rootObject || new createjs.Container();
  this.viewer = options.viewer;
  this.withOrientation = options.withOrientation || true;

  this.navigator = null;

  var client = new ROS2D.OccupancyGridClient({
    ros: this.ros,
    rootObject: this.rootObject,
    topic: topic,
  });

  client.on("change", function () {
    that.navigator = new NAV2D.Navigator({
      ros: that.ros,
      serverName: that.serverName,
      actionName: that.actionName,
      rootObject: that.rootObject,
      withOrientation: that.withOrientation,
      viewer: that.viewer, // Pass the viewer to the navigator
    });

    that.viewer.scaleToDimensions(
      client.currentGrid.width,
      client.currentGrid.height
    );
    that.viewer.shift(
      client.currentGrid.pose.position.x,
      client.currentGrid.pose.position.y
    );
  });

  client.on("error", function (error) {
    console.error("Error in OccupancyGridClient: ", error);
  });
};

NAV2D.Navigator = function (options) {
  var that = this;
  options = options || {};
  var ros = options.ros;
  var serverName = options.serverName || "/navigate_to_pose";
  var actionName = options.actionName || "nav2_msgs/NavigateToPose";
  var withOrientation = options.withOrientation || false;
  this.rootObject = options.rootObject || new createjs.Container();
  var viewer = options.viewer;

  // Add LaserScan visualization (initially hidden)
  this.laserScanClient = new ROS2D.LaserScan({
    ros: ros,
    rootObject: this.rootObject,
    topic: options.laserScanTopic || "/scan",
  });
  this.laserScanClient.visible = false;

  var ws = new WebSocket("ws://localhost:3000");

  ws.onopen = function () {
    console.log("WebSocket connection opened");
  };

  ws.onerror = function (error) {
    console.error("WebSocket error: ", error);
  };

  ws.onmessage = function (event) {
    var message = JSON.parse(event.data);
    console.log("Received message: ", message);
    if (message.type === "goal_result") {
      console.log("Received goal result: ", message.result);
      if (message.result === "SUCCEEDED") {
        // Remove goal marker if navigation succeeded
        if (goalMarker) {
          that.rootObject.removeChild(goalMarker);
          goalMarker = null;
        }
        // Clear the path visualization
        if (pathShape) {
          that.rootObject.removeChild(pathShape);
          pathShape = null;
        }
      }
    } else if (message.type === "goal_error") {
      console.error("Goal error: ", message.error);
    } else if (message.type === "message_error") {
      console.error("Message error: ", message.error);
    } else {
      console.error("Unknown message type: ", message.type);
    }
  };

  var goalMarker = null; // Define goalMarker globally within NAV2D.Navigator
  var pathShape = null; // Shape for the path visualization
  var isInitialized = false;

  function sendGoal(pose) {
    var goalMessage = {
      type: "send_goal",
      x: pose.position.x,
      y: pose.position.y,
      z: pose.orientation.z,
      w: pose.orientation.w,
    };

    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(goalMessage));
      console.log("Sending goal with coordinates: ", goalMessage);
    } else {
      console.error("WebSocket is not connected.");
    }

    // Place goal marker at the goal position
    if (goalMarker) {
      that.rootObject.removeChild(goalMarker);
    }

    goalMarker = new ROS2D.NavigationArrow({
      size: 0.1,
      strokeSize: 0.06,
      fillColor: createjs.Graphics.getRGB(0, 255, 0, 0.66),
      pulse: true,
    });
    goalMarker.x = pose.position.x;
    goalMarker.y = -pose.position.y;
    goalMarker.rotation = stage.rosQuaternionToGlobalTheta(pose.orientation);
    goalMarker.scaleX = 1.0 / stage.scaleX;
    goalMarker.scaleY = 1.0 / stage.scaleY;

    that.rootObject.addChild(goalMarker);

    // Draw the path from the robot to the goal
    if (pathShape) {
      that.rootObject.removeChild(pathShape);
    }

    pathShape = new createjs.Shape();
    pathShape.graphics.setStrokeStyle(1).beginStroke("blue");
    pathShape.graphics.moveTo(robotMarker.x, robotMarker.y);
    pathShape.graphics.lineTo(goalMarker.x, goalMarker.y);
    pathShape.graphics.endStroke();

    that.rootObject.addChild(pathShape);
  }

  var stage;
  if (that.rootObject instanceof createjs.Stage) {
    stage = that.rootObject;
  } else {
    stage = that.rootObject.getStage();
  }

  var robotMarker = new ROS2D.NavigationArrow({
    size: 0.5,
    strokeSize: 0.1,
    fillColor: createjs.Graphics.getRGB(255, 128, 0, 0.66),
    pulse: true,
    visible: false, // Set initial visibility to false
  });

  this.rootObject.addChild(robotMarker);

  // Subscribe to robot's position topic
  var poseListener = new ROSLIB.Topic({
    ros: ros,
    name: "/amcl_pose",
    messageType: "geometry_msgs/PoseWithCovarianceStamped",
    throttle_rate: 1,
  });

  var initScaleSet = false;

  poseListener.subscribe(function (message) {
    if (!isInitialized) return; // Don't update until initialized

    console.log("Subscribed to /odom");

    var x = message.pose.pose.position.x;
    var y = -message.pose.pose.position.y;
    var orientation = message.pose.pose.orientation;

    robotMarker.x = x;
    robotMarker.y = y;
    if (!initScaleSet) {
      robotMarker.scaleX = 1.0 / stage.scaleX;
      robotMarker.scaleY = 1.0 / stage.scaleY;
      initScaleSet = true;
    }
    robotMarker.rotation = stage.rosQuaternionToGlobalTheta(orientation);
    robotMarker.visible = true;

    // Update laser scan position and orientation
    that.rootObject.children.forEach(function (child) {
      if (
        child instanceof createjs.Shape &&
        child !== robotMarker &&
        child !== goalMarker
      ) {
        child.x = x;
        child.y = y;
        child.rotation = robotMarker.rotation;
      }
    });

    // Update the path visualization
    if (pathShape && goalMarker) {
      pathShape.graphics.clear();
      pathShape.graphics.setStrokeStyle(1).beginStroke("blue");
      pathShape.graphics.moveTo(robotMarker.x, robotMarker.y);
      pathShape.graphics.lineTo(goalMarker.x, goalMarker.y);
      pathShape.graphics.endStroke();
    }

    stage.update();
  });

  poseListener.on("error", function (error) {
    console.error("Error in Pose Listener: ", error);
  });

  function publishInitialPose(pose) {
    var initialPosePublisher = new ROSLIB.Topic({
      ros: ros,
      name: "/initialpose",
      messageType: "geometry_msgs/PoseWithCovarianceStamped",
    });

    var initialPose = new ROSLIB.Message({
      header: {
        frame_id: "map",
        stamp: { secs: 0, nsecs: 0 },
      },
      pose: {
        pose: {
          position: pose.position,
          orientation: pose.orientation,
        },
        covariance: [
          0.25, 0, 0, 0, 0, 0, 0, 0.25, 0, 0, 0, 0, 0, 0, 0.25, 0, 0, 0, 0, 0,
          0, 0.25, 0, 0, 0, 0, 0, 0, 0.25, 0, 0, 0, 0, 0, 0, 0.0685,
        ],
      },
    });

    initialPosePublisher.publish(initialPose);
    console.log("Published initial pose: ", initialPose);
  }

  function initializeRobotMarker(pose) {
    isInitialized = true;
    robotMarker.x = pose.position.x;
    robotMarker.y = -pose.position.y;
    robotMarker.rotation = stage.rosQuaternionToGlobalTheta(pose.orientation);
    robotMarker.visible = true;
    that.laserScanClient.visible = true;
    stage.update();

    // Publish the initial pose
    publishInitialPose(pose);
  }

  var position = null;
  var positionVec3 = null;
  var thetaRadians = 0;
  var thetaDegrees = 0;
  var orientationMarker = null;
  var mouseDown = false;
  var xDelta = 0;
  var yDelta = 0;
  var initializing = false;
  var navigating = false;

  var mouseEventHandler = function (event, mouseState) {
    if (mouseState === "down") {
      position = stage.globalToRos(event.stageX, event.stageY);
      positionVec3 = new ROSLIB.Vector3(position);
      mouseDown = true;
    }
    if (mouseState === "move") {
      that.rootObject.removeChild(orientationMarker);
      if (mouseDown === true) {
        var currentPos = stage.globalToRos(event.stageX, event.stageY);
        xDelta = currentPos.x - positionVec3.x;
        yDelta = currentPos.y - positionVec3.y;

        thetaRadians = Math.atan2(xDelta, yDelta);

        thetaDegrees = (thetaRadians - Math.PI / 2.0) * -1;
        orientationMarker = new ROS2D.NavigationArrow({
          size: 15,
          strokeSize: 1,
          fillColor: createjs.Graphics.getRGB(0, 255, 0, 0.66),
          pulse: false,
        });

        orientationMarker.x = positionVec3.x;
        orientationMarker.y = -positionVec3.y;
        orientationMarker.rotation = stage.rosQuaternionToGlobalTheta({
          x: 0,
          y: 0,
          z: Math.sin(-thetaRadians / 2.0),
          w: Math.cos(-thetaRadians / 2.0),
        });
        orientationMarker.scaleX = 1.0 / stage.scaleX;
        orientationMarker.scaleY = 1.0 / stage.scaleY;
        that.rootObject.addChild(orientationMarker);
      }
    }
    if (mouseState === "up") {
      mouseDown = false;
      if (initializing) {
        // Inisialisasi posisi robot
        initializeRobotMarker({
          position: positionVec3,
          orientation: {
            x: 0,
            y: 0,
            z: Math.sin(-thetaRadians / 2.0),
            w: Math.cos(-thetaRadians / 2.0),
          },
        });
        initializing = false; // Reset mode inisialisasi setelah digunakan
      } else if (navigating) {
        // Kirim tujuan navigasi
        sendGoal({
          position: positionVec3,
          orientation: {
            x: 0,
            y: 0,
            z: Math.sin(-thetaRadians / 2.0),
            w: Math.cos(-thetaRadians / 2.0),
          },
        });
        navigating = false; // Reset mode navigasi setelah digunakan
      }
    }
  };

  stage.addEventListener("stagemousedown", function (event) {
    mouseEventHandler(event, "down");
  });

  stage.addEventListener("stagemousemove", function (event) {
    mouseEventHandler(event, "move");
  });

  stage.addEventListener("stagemouseup", function (event) {
    mouseEventHandler(event, "up");
  });

  this.initializeRobotMode = function () {
    initializing = true;
    navigating = false; // Reset navigasi saat mode inisialisasi diaktifkan
  };

  this.navigateMode = function () {
    navigating = true;
    initializing = false; // Reset inisialisasi saat mode navigasi diaktifkan
  };
};
